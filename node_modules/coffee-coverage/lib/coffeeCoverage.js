// Generated by CoffeeScript 1.9.1
(function() {
  var CoverageError, EXTENSIONS, StringStream, abbreviatedPath, coffeeScript, debug, defaults, endsWith, events, excludeFile, factoryDefaults, fs, getRelativeFilename, mkdirs, path, pkginfo, ref, statFile, stripLeadingDotOrSlash, util,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  coffeeScript = require('coffee-script');

  events = require('events');

  fs = require('fs');

  util = require('util');

  path = require('path');

  path.sep = path.sep || "/";

  ref = require('./helpers'), endsWith = ref.endsWith, defaults = ref.defaults, abbreviatedPath = ref.abbreviatedPath, mkdirs = ref.mkdirs, stripLeadingDotOrSlash = ref.stripLeadingDotOrSlash, statFile = ref.statFile, getRelativeFilename = ref.getRelativeFilename, excludeFile = ref.excludeFile;

  EXTENSIONS = require('./constants').EXTENSIONS;

  pkginfo = require('pkginfo')(module, 'version', 'author', 'contributors');

  debug = function() {};

  CoverageError = (function(superClass) {
    extend(CoverageError, superClass);

    function CoverageError(message) {
      this.message = message;
      this.name = "CoverageError";
      Error.call(this);
      Error.captureStackTrace(this, arguments.callee);
    }

    return CoverageError;

  })(Error);

  StringStream = (function() {
    function StringStream() {
      this.data = "";
    }

    StringStream.prototype.write = function(data) {
      return this.data += data;
    };

    return StringStream;

  })();

  factoryDefaults = {
    coverageVar: '_$jscoverage',
    exclude: [],
    recursive: true,
    bare: false
  };

  exports.register = function(options) {
    var actualOptions, coverage, instrumentFile, module, origStreamineCoffeeHandler, replaceHandler, streamline_js;
    actualOptions = defaults({}, options);
    if (actualOptions.basePath) {
      actualOptions.basePath = path.resolve(actualOptions.basePath);
      if (actualOptions.initAll) {
        actualOptions.initFileStream = new StringStream();
      }
    }
    coverage = new exports.CoverageInstrumentor(actualOptions);
    module = require('module');
    if (actualOptions.basePath && actualOptions.initAll) {
      coverage.instrumentDirectory(actualOptions.basePath, null);
      eval(actualOptions.initFileStream.data);
    }
    instrumentFile = function(fileName) {
      var content, coverageFileName, instrumented;
      content = fs.readFileSync(fileName, 'utf8');
      coverageFileName = getRelativeFilename(actualOptions.basePath, fileName);
      instrumented = coverage.instrumentCoffee(coverageFileName, content);
      return instrumented.init + instrumented.js;
    };
    replaceHandler = function(extension) {
      var origCoffeeHandler;
      origCoffeeHandler = require.extensions[extension];
      return require.extensions[extension] = function(module, fileName) {
        if (excludeFile(fileName, options)) {
          return origCoffeeHandler.call(this, module, fileName);
        }
        return module._compile(instrumentFile(fileName), fileName);
      };
    };
    replaceHandler(".coffee");
    replaceHandler(".litcoffee");
    replaceHandler(".coffee.md");
    if (actualOptions.streamlinejs) {
      streamline_js = require.extensions["._js"];
      if (streamline_js) {
        origStreamineCoffeeHandler = require.extensions["._coffee"];
        return require.extensions["._coffee"] = function(module, fileName) {
          var compiled;
          if (excludeFile(fileName, options)) {
            return origStreamineCoffeeHandler.call(this, module, fileName);
          }
          compiled = instrumentFile(fileName);
          return streamline_js(module, fileName, compiled, null);
        };
      }
    }
  };

  exports.CoverageInstrumentor = (function(superClass) {
    var fileToLines, fixLocationData, generateUniqueName, getEffectiveOptions, nodeType, toQuotedString, validateSrcDest, writeToFile;

    extend(CoverageInstrumentor, superClass);

    function CoverageInstrumentor(options) {
      var actualOptions;
      if (options == null) {
        options = {};
      }
      actualOptions = defaults({}, options);
      this.defaultOptions = defaults(actualOptions, factoryDefaults);
    }

    toQuotedString = function(string) {
      var answer;
      answer = string.replace(/\\/g, '\\\\');
      return '"' + (answer.replace(/"/g, '\\\"')) + '"';
    };

    fileToLines = function(fileData) {
      var dataWithFixedLfs;
      dataWithFixedLfs = fileData.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
      return dataWithFixedLfs.split("\n");
    };

    nodeType = function(node) {
      var ref1;
      return (node != null ? (ref1 = node.constructor) != null ? ref1.name : void 0 : void 0) || null;
    };

    writeToFile = function(outFile, content) {
      return fs.writeFileSync(outFile, content);
    };

    validateSrcDest = function(source, out) {
      var outStat, sourceStat;
      sourceStat = statFile(source);
      outStat = out ? statFile(out) : null;
      if (!sourceStat) {
        throw new CoverageError("Source file " + source + " does not exist.");
      }
      if (outStat) {
        if (sourceStat.isFile() && outStat.isDirectory()) {
          throw new CoverageError("Refusing to overwrite directory " + out + " with file.");
        }
        if (sourceStat.isDirectory() && outStat.isFile()) {
          throw new CoverageError("Refusing to overwrite file " + out + " with directory.");
        }
      }
    };

    generateUniqueName = function(usedNames, desiredName) {
      var answer, suffix;
      answer = "";
      suffix = 1;
      while (true) {
        answer = desiredName + " (" + suffix + ")";
        if (!(indexOf.call(usedNames, answer) >= 0)) {
          break;
        }
        suffix++;
      }
      return answer;
    };

    CoverageInstrumentor.prototype.instrument = function(source, out, options) {
      var sourceStat;
      if (options == null) {
        options = {};
      }
      validateSrcDest(source, out);
      sourceStat = statFile(source);
      if (sourceStat.isFile()) {
        return this.instrumentFile(source, out, options);
      } else if (sourceStat.isDirectory()) {
        return this.instrumentDirectory(source, out, options);
      } else {
        throw new CoverageError("Can't instrument " + source + ".");
      }
    };

    CoverageInstrumentor.prototype.getOutputFileName = function(fileName) {
      var coffee_extension, ext, outFile;
      if (fileName == null) {
        return null;
      }
      outFile = fileName;
      for (coffee_extension in EXTENSIONS) {
        ext = EXTENSIONS[coffee_extension];
        if (endsWith(fileName.toLowerCase(), coffee_extension)) {
          outFile = fileName.slice(0, +(-(coffee_extension.length + 1)) + 1 || 9e9) + ext.js_extension;
          break;
        }
      }
      return outFile;
    };

    getEffectiveOptions = function(options, defaultOptions) {
      var effectiveOptions;
      if (options == null) {
        options = {};
      }
      effectiveOptions = defaults({}, options);
      return defaults(effectiveOptions, defaultOptions);
    };

    CoverageInstrumentor.prototype.instrumentDirectory = function(sourceDirectory, outDirectory, options) {
      var answer, coffee_extension, effectiveOptions, file, i, inst, instrumentOptions, len, outDirectoryStat, outFile, outputDirectoryExists, processed, ref1, sourceDirectoryMode, sourceFile, sourceStat;
      if (options == null) {
        options = {};
      }
      sourceDirectory = path.resolve(sourceDirectory);
      this.emit("instrumentingDirectory", sourceDirectory, outDirectory);
      effectiveOptions = getEffectiveOptions(options, this.defaultOptions);
      effectiveOptions.usedFileNames = effectiveOptions.usedFileNames || [];
      effectiveOptions.basePath = effectiveOptions.basePath ? path.resolve(effectiveOptions.basePath) : sourceDirectory;
      answer = {
        lines: 0
      };
      validateSrcDest(sourceDirectory, outDirectory);
      if (!endsWith(sourceDirectory, path.sep)) {
        sourceDirectory += path.sep;
      }
      sourceDirectoryMode = (statFile(sourceDirectory)).mode;
      if (outDirectory) {
        if (!endsWith(outDirectory, path.sep)) {
          outDirectory += path.sep;
        }
        outDirectoryStat = statFile(outDirectory);
        outputDirectoryExists = !!outDirectoryStat;
      }
      ref1 = fs.readdirSync(sourceDirectory);
      for (i = 0, len = ref1.length; i < len; i++) {
        file = ref1[i];
        sourceFile = sourceDirectory + file;
        if (excludeFile(sourceFile, effectiveOptions)) {
          this.emit("skip", sourceDirectory + file);
          continue;
        }
        outFile = outDirectory ? outDirectory + file : null;
        sourceStat = statFile(sourceFile);
        if (effectiveOptions.recursive && sourceStat.isDirectory()) {
          inst = this.instrumentDirectory(sourceFile, outFile, effectiveOptions);
          answer.lines += inst.lines;
        } else {
          processed = false;
          for (coffee_extension in EXTENSIONS) {
            if (coffee_extension === '._coffee') {
              continue;
            }
            if (endsWith(file.toLowerCase(), coffee_extension) && sourceStat.isFile()) {
              if ((outDirectory != null) && !outputDirectoryExists) {
                mkdirs(outDirectory, sourceDirectoryMode);
                outputDirectoryExists = true;
              }
              outFile = this.getOutputFileName(outFile);
              instrumentOptions = defaults({}, effectiveOptions);
              instrumentOptions.fileName = getRelativeFilename(options.basePath, sourceFile);
              inst = this.instrumentFile(sourceFile, outFile, instrumentOptions);
              answer.lines += inst.lines;
              processed = true;
              break;
            }
          }
        }
      }
      return answer;
    };

    CoverageInstrumentor.prototype.instrumentFile = function(sourceFile, outFile, options) {
      var answer, data, effectiveOptions;
      if (outFile == null) {
        outFile = null;
      }
      if (options == null) {
        options = {};
      }
      this.emit("instrumentingFile", sourceFile, outFile);
      effectiveOptions = getEffectiveOptions(options, this.defaultOptions);
      validateSrcDest(sourceFile, outFile);
      data = fs.readFileSync(sourceFile, 'utf8');
      answer = this.instrumentCoffee(effectiveOptions.fileName || sourceFile, data, effectiveOptions);
      if (outFile) {
        writeToFile(outFile, answer.init + answer.js);
      }
      return answer;
    };

    fixLocationData = function(instrumentedLine, line) {
      var doIt;
      doIt = function(node) {
        return node.locationData = {
          first_line: line - 1,
          first_column: 0,
          last_line: line - 1,
          last_column: 0
        };
      };
      doIt(instrumentedLine);
      return instrumentedLine.eachChild(doIt);
    };

    CoverageInstrumentor.prototype.instrumentCoffee = function(fileName, fileData, options) {
      var answer, ast, coffeeOptions, effectiveOptions, err, fileToInstrumentLines, i, index, init, instrumentTree, instrumentedLines, j, js, len, len1, line, lineNumber, literate, origFileName, quotedFileName, ref1, token, tokens;
      if (options == null) {
        options = {};
      }
      origFileName = fileName;
      literate = /\.(litcoffee|coffee\.md)$/.test(fileName);
      effectiveOptions = getEffectiveOptions(options, this.defaultOptions);
      switch (effectiveOptions.path) {
        case 'relative':
          fileName = stripLeadingDotOrSlash(fileName);
          break;
        case 'abbr':
          fileName = abbreviatedPath(stripLeadingDotOrSlash(fileName));
          break;
        default:
          fileName = path.basename(fileName);
      }
      if (effectiveOptions.usedfileNames) {
        if (indexOf.call(effectiveOptions.usedfileNames, fileName) >= 0) {
          fileName = generateUniqueName(effectiveOptions.usedfileNames, fileName);
        }
        effectiveOptions.usedfileNames.push(fileName);
      }
      quotedFileName = toQuotedString(fileName);
      coffeeOptions = {
        bare: effectiveOptions.bare,
        literate: literate
      };
      try {
        tokens = coffeeScript.tokens(fileData, coffeeOptions);
        coffeeOptions.referencedVars = (function() {
          var i, len, results;
          results = [];
          for (i = 0, len = tokens.length; i < len; i++) {
            token = tokens[i];
            if (token.variable) {
              results.push(token[1]);
            }
          }
          return results;
        })();
        ast = coffeeScript.nodes(tokens);
      } catch (_error) {
        err = _error;
        throw new CoverageError("Could not parse " + fileName + ": " + err.stack);
      }
      instrumentedLines = [];
      instrumentTree = (function(_this) {
        return function(node, parent, depth) {
          var childIndex, children, doAnnotation, expression, instrumentedLine, line, results;
          if (parent == null) {
            parent = null;
          }
          if (depth == null) {
            depth = 0;
          }
          debug("Examining  l:" + (node.locationData.first_line + 1) + " d:" + depth + " " + (nodeType(node)));
          if ((nodeType(node) !== "Block") || node.coffeeCoverageDoNotInstrument) {
            if (nodeType(node) === "If" && node.isChain) {
              debug("  Disabling chaining for if statement");
              node.isChain = false;
            }
            return node.eachChild(function(child) {
              return instrumentTree(child, node, depth + 1);
            });
          } else {
            children = node.expressions;
            childIndex = 0;
            results = [];
            while (childIndex < children.length) {
              expression = children[childIndex];
              line = expression.locationData.first_line + 1;
              doAnnotation = true;
              if (nodeType(expression) === "Comment") {
                doAnnotation = false;
              }
              if (indexOf.call(instrumentedLines, line) >= 0) {
                debug("Skipping   l:" + line + " d:" + (depth + 1) + " " + (nodeType(expression)));
                doAnnotation = false;
              }
              if (doAnnotation) {
                debug("Annotating l:" + line + " d:" + (depth + 1) + " " + (nodeType(expression)));
                instrumentedLines.push(line);
                instrumentedLine = coffeeScript.nodes(effectiveOptions.coverageVar + "[" + quotedFileName + "][" + line + "]++");
                fixLocationData(instrumentedLine, line);
                children.splice(childIndex, 0, instrumentedLine);
                childIndex++;
              }
              instrumentTree(expression, node, depth + 1);
              results.push(childIndex++);
            }
            return results;
          }
        };
      })(this);
      instrumentTree(ast);
      init = "if (typeof " + effectiveOptions.coverageVar + " === 'undefined') " + effectiveOptions.coverageVar + " = {};\n(function(_export) {\n    if (typeof _export." + effectiveOptions.coverageVar + " === 'undefined') {\n        _export." + effectiveOptions.coverageVar + " = " + effectiveOptions.coverageVar + ";\n    }\n})(typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : this);\nif (! " + effectiveOptions.coverageVar + "[" + quotedFileName + "]) {\n    " + effectiveOptions.coverageVar + "[" + quotedFileName + "] = [];\n";
      for (i = 0, len = instrumentedLines.length; i < len; i++) {
        lineNumber = instrumentedLines[i];
        init += "    " + effectiveOptions.coverageVar + "[" + quotedFileName + "][" + lineNumber + "] = 0;\n";
      }
      init += "}\n\n";
      init += effectiveOptions.coverageVar + "[" + quotedFileName + "].source = [";
      fileToInstrumentLines = fileToLines(fileData);
      for (index = j = 0, len1 = fileToInstrumentLines.length; j < len1; index = ++j) {
        line = fileToInstrumentLines[index];
        if (!!index) {
          init += ", ";
        }
        init += toQuotedString(line);
      }
      init += "];\n\n";
      try {
        js = ast.compile(coffeeOptions);
      } catch (_error) {
        err = _error;
        throw new CoverageError("Could not compile " + fileName + " after annotating: " + err.stack);
      }
      if ((ref1 = effectiveOptions.initFileStream) != null) {
        ref1.write(init);
      }
      answer = {
        init: init,
        js: js,
        lines: instrumentedLines.length
      };
      return answer;
    };

    return CoverageInstrumentor;

  })(events.EventEmitter);

}).call(this);
