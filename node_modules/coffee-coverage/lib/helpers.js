// Generated by CoffeeScript 1.9.1
(function() {
  var EXTENSIONS, fs, path, startsWith, statFile,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  fs = require('fs');

  path = require('path');

  path.sep = path.sep || "/";

  EXTENSIONS = require('./constants').EXTENSIONS;

  startsWith = function(str, prefix) {
    return str.slice(0, +(prefix.length - 1) + 1 || 9e9) === prefix;
  };

  exports.endsWith = function(str, suffix) {
    return str.slice(-suffix.length) === suffix;
  };

  exports.defaults = function(dest, src) {
    var key, val;
    if (!dest) {
      dest = {};
    }
    for (key in src) {
      val = src[key];
      if (!(key in dest)) {
        dest[key] = val;
      }
    }
    return dest;
  };

  exports.stripLeadingDotOrSlash = function(pathName) {
    return pathName.replace(/^\//, "").replace(/^\.\//, "");
  };

  exports.statFile = statFile = function(file) {
    var answer, err;
    try {
      answer = fs.statSync(file);
    } catch (_error) {
      err = _error;
      if ('code' in err && err.code === 'ENOENT') {
        answer = null;
      } else {
        throw err;
      }
    }
    return answer;
  };

  exports.mkdirs = function(dirPath, mode) {
    var currentPath, i, len, pathElement, pathElements, results, stat;
    if (!statFile(dirPath)) {
      pathElements = dirPath.split(path.sep);
      currentPath = "";
      results = [];
      for (i = 0, len = pathElements.length; i < len; i++) {
        pathElement = pathElements[i];
        if (!pathElement) {
          continue;
        }
        currentPath += pathElement + path.sep;
        stat = statFile(currentPath);
        if (stat && !stat.isDirectory()) {
          throw new CoverageError("Can't create directory " + currentPath + ": file already exists.");
        }
        if (!stat) {
          results.push(fs.mkdirSync(currentPath, mode));
        } else {
          results.push(void 0);
        }
      }
      return results;
    }
  };

  exports.abbreviatedPath = function(pathName) {
    var answer, filename, i, len, needTrailingSlash, pathElement, splitPath;
    needTrailingSlash = false;
    splitPath = pathName.split(path.sep);
    if (splitPath.slice(-1)[0] === '') {
      needTrailingSlash = true;
      splitPath.pop();
    }
    filename = splitPath.pop();
    answer = "";
    for (i = 0, len = splitPath.length; i < len; i++) {
      pathElement = splitPath[i];
      if (pathElement.length === 0) {
        answer += "";
      } else if (pathElement === "..") {
        answer += pathElement;
      } else if (startsWith(pathElement, ".")) {
        answer += pathElement.slice(0, 2);
      } else {
        answer += pathElement[0];
      }
      answer += path.sep;
    }
    answer += filename;
    if (needTrailingSlash) {
      answer += path.sep;
    }
    return answer;
  };

  exports.getRelativeFilename = function(basePath, fileName) {
    var relativeFileName;
    relativeFileName = path.resolve(fileName);
    if ((basePath != null) && startsWith(relativeFileName, basePath)) {
      relativeFileName = path.relative(basePath, fileName);
    }
    return relativeFileName;
  };

  exports.excludeFile = function(fileName, options) {
    var basePath, component, components, exclude, excludePath, excluded, i, j, k, len, len1, len2, ref, relativeFilename;
    basePath = options.basePath;
    exclude = options.exclude;
    if (!exclude) {
      return;
    }
    excluded = false;
    if (basePath) {
      relativeFilename = exports.getRelativeFilename(basePath, fileName);
      if (relativeFilename === fileName) {
        excluded = true;
      }
      components = relativeFilename.split(path.sep);
      for (i = 0, len = components.length; i < len; i++) {
        component = components[i];
        if (indexOf.call(exclude, component) >= 0) {
          excluded = true;
        }
      }
      if (!excluded) {
        for (j = 0, len1 = exclude.length; j < len1; j++) {
          excludePath = exclude[j];
          if (startsWith("/" + relativeFilename, excludePath) || startsWith(relativeFilename, excludePath)) {
            excluded = true;
          }
        }
      }
    }
    if (!excluded && (ref = !path.extname(fileName), indexOf.call(Object.keys(EXTENSIONS), ref) >= 0)) {
      excluded = true;
    }
    if (!excluded) {
      for (k = 0, len2 = exclude.length; k < len2; k++) {
        excludePath = exclude[k];
        if (startsWith(fileName, excludePath)) {
          excluded = true;
        }
      }
    }
    return excluded;
  };

}).call(this);
